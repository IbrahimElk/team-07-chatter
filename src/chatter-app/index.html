<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <title>3D-map</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three/build/three.module.js';
      import {
        WebGLRenderer,
        ACESFilmicToneMapping,
        sRGBEncoding,
        Color,
        CylinderGeometry,
        RepeatWrapping,
        DoubleSide,
        BoxGeometry,
        Mesh,
        PointLight,
        MeshPhysicalMaterial,
        PerspectiveCamera,
        Scene,
        PMREMGenerator,
        PCFSoftShadowMap,
        Vector2,
        TextureLoader,
        SphereGeometry,
        MeshStandardMaterial,
      } from 'https://cdn.skypack.dev/three@0.137';
      import { OrbitControls } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/controls/OrbitControls';
      import { RGBELoader } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/loaders/RGBELoader';
      import { mergeBufferGeometries } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/utils/BufferGeometryUtils';

      const scene = new THREE.Scene();
      const camera = new PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 1000);
      //camera.position.set(-17, 31, 33);
      camera.position.z = 20;

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = ACESFilmicToneMapping;
      renderer.outputEncoding = sRGBEncoding;
      //renderer.renderer.useLegacyLights = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.dampingFactor = 0.05;
      controls.enableDamping = true;

      //HEIGHTS:
      let heightsaver = 0.0001;
      let hk200 = 0.5;
      let hacco = 0.3;
      let hlm200 = 0.5;
      let hs200 = 0.7;
      let ha200 = 1.1;

      let geoGround = new THREE.BoxGeometry(25, 0, 15);
      let geoCentralCube = new THREE.BoxGeometry(0.1, 0.1, 0.1);
      let geok200 = new THREE.BoxGeometry(1.3, hk200, 1.9);
      geok200.translate(-9.85, heightsaver + hk200 * 0.5, -0.65);
      let geoAcco = new THREE.BoxGeometry(0.8, hacco, 3.3);
      geoAcco.translate(-11, heightsaver + hacco * 0.5, 0.25);
      let geol200 = new THREE.BoxGeometry(1.3, hlm200, 2.0);
      geol200.translate(-8.15, heightsaver + hlm200 * 0.5, -3.3);
      let geos200 = new THREE.BoxGeometry(0.6, hs200, 1.3);
      geos200.translate(-7.2, heightsaver + hs200 * 0.5, -3.65);
      let geom200 = new THREE.BoxGeometry(1.8, hlm200, 1.9);
      geom200.translate(-6, heightsaver + hlm200 * 0.5, -3.75);
      let geoa200 = new THREE.BoxGeometry(0, 0, 0);
      makeBuilding('a200', ha200, 3.6, 0.9, -7.2, 1.4);
      makeBuilding('a200', ha200, 0.7, 0.1, -7.15, 0.95);
      makeBuilding('a200', ha200, 0.7, 0.1, -7.15, 1.9);

      let centralCube = new THREE.Mesh(geoCentralCube, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      scene.add(centralCube);
      let ground = new THREE.Mesh(geoGround, new THREE.MeshBasicMaterial({ color: 0x00ff00 }));
      scene.add(ground);
      let k200 = new THREE.Mesh(geok200, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      scene.add(k200);
      let acco = new THREE.Mesh(geoAcco, new THREE.MeshBasicMaterial({ color: 0x000020 }));
      scene.add(acco);
      let s200 = new THREE.Mesh(geos200, new THREE.MeshBasicMaterial({ color: 0xdd0022 }));
      scene.add(s200);
      let m200 = new THREE.Mesh(geom200, new THREE.MeshBasicMaterial({ color: 0xff0000 }));
      scene.add(m200);
      let l200 = new THREE.Mesh(geol200, new THREE.MeshBasicMaterial({ color: 0xff00ff }));
      scene.add(l200);
      let a200 = new THREE.Mesh(geoa200, new THREE.MeshBasicMaterial({ color: 0xfcba03 }));
      scene.add(a200);

      function makeBuilding(building, height, xlength, zlength, xtranslate, ztranslate) {
        let geo = new THREE.BoxGeometry(xlength, height, zlength);
        geo.translate(xtranslate, heightsaver + height * 0.5, ztranslate);
        if (building == 'a200') {
          geoa200 = mergeBufferGeometries([geo, geoa200]);
        }
      }

      function animate() {
        requestAnimationFrame(animate);

        controls.update();

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>

<!-- <!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <title>3D-map</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three/build/three.module.js';
      import {
        WebGLRenderer,
        ACESFilmicToneMapping,
        sRGBEncoding,
        Color,
        CylinderGeometry,
        RepeatWrapping,
        DoubleSide,
        BoxGeometry,
        Mesh,
        PointLight,
        MeshPhysicalMaterial,
        PerspectiveCamera,
        Scene,
        PMREMGenerator,
        PCFSoftShadowMap,
        Vector2,
        TextureLoader,
        SphereGeometry,
        MeshStandardMaterial,
      } from 'https://cdn.skypack.dev/three@0.137';
      import { OrbitControls } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/controls/OrbitControls';
      import { RGBELoader } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/loaders/RGBELoader';
      import { mergeBufferGeometries } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/utils/BufferGeometryUtils';

      const scene = new THREE.Scene();
      const camera = new PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 1000);
      camera.position.set(-17, 31, 33);

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = ACESFilmicToneMapping;
      renderer.outputEncoding = sRGBEncoding;
      //renderer.renderer.useLegacyLights = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.dampingFactor = 0.05;
      controls.enableDamping = true;

      // (async function () {
      //   makeCube(3, new THREE.Vector2(0, 0));
      //   let groundplanMesh = new THREE.Mesh(cubes, new THREE.MeshBasicMaterial({ color: 0x00e600 }));
      //   scene.add(groundplanMesh);
      // });

      const GROUNDHEIGHT = 0.5;

      let cubes = new THREE.BoxGeometry(0, 0, 0);
      let groundGeo = new THREE.BoxGeometry(0, 0, 0);

      function makeCube(height, position) {
        let geo = new THREE.BoxGeometry(1, height, 1);
        geo.translate(position.x, height * 0.5, position.y);
        if (height == GROUNDHEIGHT) {
          groundGeo = mergeBufferGeometries([geo, groundGeo]);
        } else {
          cubes = mergeBufferGeometries([cubes, geo]);
        }
      }

      // let envmap;

      // (async function () {
      //   let pmrem = new THREE.PMREMGenerator(renderer);
      //   let envmapTexture = await new THREE.RGBELoader().setDataType(FloatType).loadAssync('assets/envmap.hdr');
      //   envmap = pmrem.fromEquirectangular(envmapTexture).texture;
      //   makHex(3, new THREE.Vector2(0, 0));
      //   let hexagonMesh = new THREE.Mesh(
      //     geometry,
      //     new THREE.MeshStandardMaterial({ envmap: envmap, flatShading: true })
      //   );
      //   scene.add(hexagonMesh);
      // });

      let hexagongeometries = new THREE.BoxGeometry(0, 0, 0);

      function hexGeometry(height, position) {
        let geo = new THREE.CylinderGeometry(1, 1, height, 6, 1, false);
        geo.translate(position.x, height * 0.5, position.y);
        return geo;
      }

      function makHex(height, position) {
        let geo = hexGeometry(height, position);
        if (height == GROUNDHEIGHT) {
          groundGeo = mergeBufferGeometries([geo, groundGeo]);
        } else {
          hexagongeometries = mergeBufferGeometries([hexagongeometries, geo]);
        }
      }

      // const geometry = new THREE.CylinderGeometry(1, 1, 3, 6, 1, false);
      // const material = new THREE.MeshBasicMaterial({ color: 0x00e600 });
      // const hex = new THREE.Mesh(geometry, material);
      // scene.add(hex);

      // const geometry = new THREE.BoxGeometry(1, 0, 1);
      // const material = new THREE.MeshBasicMaterial({ color: 0x00e600 });
      // const cube = new THREE.Mesh(geometry, material);
      // scene.add(cube);

      // camera.position.z = 5;

      // makHex(3, new THREE.Vector2(0, 0));
      // let hexagonMesh = new THREE.Mesh(hexagongeometries, new THREE.MeshBasicMaterial({ color: 0x00e600 }));
      // scene.add(hexagonMesh);

      function tileToPosition(tileX, tileY) {
        //return new THREE.Vector2((tileX + (tileY % 2) * 0.5) * 1.77, tileY * 1.535);
        return new THREE.Vector2((tileX + 0.5) * 1.1, tileY * 1.1);
      }

      let counter = 10;
      for (let i = counter * -1; i <= counter; i++) {
        for (let j = counter * -1; j <= counter; j++) {
          if (i <= -7 && i >= -9 && j <= -7 && j >= -9) {
            makeCube(2, tileToPosition(i, j));
          } else if (i <= 8 && i >= 3 && j <= 7 && j >= 4) {
            makeCube(2, tileToPosition(i, j));
          } else {
            makeCube(0.5, tileToPosition(i, j));
          }
        }
      }

      let groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshBasicMaterial({ color: 0x00e600 }));
      scene.add(groundMesh);
      let basicMesh = new THREE.Mesh(cubes, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      scene.add(basicMesh);

      function animate() {
        requestAnimationFrame(animate);

        //cube.rotation.x += 0.01;
        //cube.rotation.y += 0.01;

        // let pmrem = new THREE.PMREMGenerator(renderer);
        // let envmapTexture = await new THREE.RGBELoader().setDataType(FloatType).loadAssync('assets/envmap.hdr');
        // envmap = pmrem.fromEquirectangular(envmapTexture).texture;

        controls.update();

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html> -->
