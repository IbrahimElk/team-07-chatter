<!DOCTYPE html>
<html lang="en">
  <head>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta charset="UTF-8" />
    <title>3D-map</title>
    <style>
      body {
        margin: 0;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from 'https://unpkg.com/three/build/three.module.js';
      import {
        WebGLRenderer,
        ACESFilmicToneMapping,
        sRGBEncoding,
        Color,
        CylinderGeometry,
        RepeatWrapping,
        DoubleSide,
        BoxGeometry,
        Mesh,
        PointLight,
        MeshPhysicalMaterial,
        PerspectiveCamera,
        Scene,
        PMREMGenerator,
        PCFSoftShadowMap,
        Vector2,
        TextureLoader,
        SphereGeometry,
        MeshStandardMaterial,
      } from 'https://cdn.skypack.dev/three@0.137';
      import { OrbitControls } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/controls/OrbitControls';
      import { RGBELoader } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/loaders/RGBELoader';
      import { mergeBufferGeometries } from 'https://cdn.skypack.dev/three-stdlib@2.8.5/utils/BufferGeometryUtils';

      const scene = new THREE.Scene();
      const camera = new PerspectiveCamera(45, innerWidth / innerHeight, 0.1, 1000);
      camera.position.set(-17, 31, 33);

      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.toneMapping = ACESFilmicToneMapping;
      renderer.outputEncoding = sRGBEncoding;
      //renderer.renderer.useLegacyLights = true;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      const controls = new OrbitControls(camera, renderer.domElement);
      controls.target.set(0, 0, 0);
      controls.dampingFactor = 0.05;
      controls.enableDamping = true;

      // (async function () {
      //   makeCube(3, new THREE.Vector2(0, 0));
      //   let groundplanMesh = new THREE.Mesh(cubes, new THREE.MeshBasicMaterial({ color: 0x00e600 }));
      //   scene.add(groundplanMesh);
      // });

      const GROUNDHEIGHT = 0.5;

      let cubes = new THREE.BoxGeometry(0, 0, 0);
      let groundGeo = new THREE.BoxGeometry(0, 0, 0);

      function makeCube(height, position) {
        let geo = new THREE.BoxGeometry(1, height, 1);
        geo.translate(position.x, height * 0.5, position.y);
        if (height == GROUNDHEIGHT) {
          groundGeo = mergeBufferGeometries([geo, groundGeo]);
        } else {
          cubes = mergeBufferGeometries([cubes, geo]);
        }
      }

      // let envmap;

      // (async function () {
      //   let pmrem = new THREE.PMREMGenerator(renderer);
      //   let envmapTexture = await new THREE.RGBELoader().setDataType(FloatType).loadAssync('assets/envmap.hdr');
      //   envmap = pmrem.fromEquirectangular(envmapTexture).texture;
      //   makHex(3, new THREE.Vector2(0, 0));
      //   let hexagonMesh = new THREE.Mesh(
      //     geometry,
      //     new THREE.MeshStandardMaterial({ envmap: envmap, flatShading: true })
      //   );
      //   scene.add(hexagonMesh);
      // });

      let hexagongeometries = new THREE.BoxGeometry(0, 0, 0);

      function hexGeometry(height, position) {
        let geo = new THREE.CylinderGeometry(1, 1, height, 6, 1, false);
        geo.translate(position.x, height * 0.5, position.y);
        return geo;
      }

      function makHex(height, position) {
        let geo = hexGeometry(height, position);
        if (height == GROUNDHEIGHT) {
          groundGeo = mergeBufferGeometries([geo, groundGeo]);
        } else {
          hexagongeometries = mergeBufferGeometries([hexagongeometries, geo]);
        }
      }

      // const geometry = new THREE.CylinderGeometry(1, 1, 3, 6, 1, false);
      // const material = new THREE.MeshBasicMaterial({ color: 0x00e600 });
      // const hex = new THREE.Mesh(geometry, material);
      // scene.add(hex);

      // const geometry = new THREE.BoxGeometry(1, 0, 1);
      // const material = new THREE.MeshBasicMaterial({ color: 0x00e600 });
      // const cube = new THREE.Mesh(geometry, material);
      // scene.add(cube);

      // camera.position.z = 5;

      // makHex(3, new THREE.Vector2(0, 0));
      // let hexagonMesh = new THREE.Mesh(hexagongeometries, new THREE.MeshBasicMaterial({ color: 0x00e600 }));
      // scene.add(hexagonMesh);

      function tileToPosition(tileX, tileY) {
        //return new THREE.Vector2((tileX + (tileY % 2) * 0.5) * 1.77, tileY * 1.535);
        return new THREE.Vector2((tileX + 0.5) * 1.1, tileY * 1.1);
      }

      let counter = 10;
      for (let i = counter * -1; i <= counter; i++) {
        for (let j = counter * -1; j <= counter; j++) {
          if (i <= -7 && i >= -9 && j <= -7 && j >= -9) {
            makeCube(2, tileToPosition(i, j));
          } else if (i <= 8 && i >= 3 && j <= 7 && j >= 4) {
            makeCube(2, tileToPosition(i, j));
          } else {
            makeCube(0.5, tileToPosition(i, j));
          }
        }
      }

      let groundMesh = new THREE.Mesh(groundGeo, new THREE.MeshBasicMaterial({ color: 0x00e600 }));
      scene.add(groundMesh);
      let basicMesh = new THREE.Mesh(cubes, new THREE.MeshBasicMaterial({ color: 0x0000ff }));
      scene.add(basicMesh);

      function animate() {
        requestAnimationFrame(animate);

        //cube.rotation.x += 0.01;
        //cube.rotation.y += 0.01;

        // let pmrem = new THREE.PMREMGenerator(renderer);
        // let envmapTexture = await new THREE.RGBELoader().setDataType(FloatType).loadAssync('assets/envmap.hdr');
        // envmap = pmrem.fromEquirectangular(envmapTexture).texture;

        controls.update();

        renderer.render(scene, camera);
      }

      animate();
    </script>
  </body>
</html>
